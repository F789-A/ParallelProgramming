# Отрисовка 3D массива полупрозрачных частиц
Выполнил: Драчев Руслан, 24151, 29.11.25

Демонстрационное видео лежит в репозитории.
## Описание задачи
Дано: 3D массив 4-значных векторов rgba (частиц)
Требуется: отрисовать данные корректно учитывая полупрозрачность частиц используя преимущественно CPU.
## Используемые библиотеки
GLWF, OpenGL - использовались для создания окна, вывода итоговой 2D текстуры на экран и обработки ввода.
GLM - использовалось для матричной математики
С процессом установки библиотек можно ознакомиться в цикле статей: https://habr.com/ru/articles/310790/ (к сожалению, не дружу с cmake:(
## Краткое описание
  Параллельность использовалась двумя способами:
    1. Работа приложения разделена на 2 потока: главный и рендер, каждый со своим MainLoop и синхронизацией между ними (распространенный архитектурный, подход использумый, например, в игровых движках (Unity и т.д) и фреймворкаx (Qt и т.д.));
    2. В потоке рендера производился "рейтрейсинг", была попытка сэмитировать работу gpu, когда каждый поток обрабатывает один свой пиксель итогового изображения, используя входные данные только readonly, т.к. на cpu мало истинный потоков, то каждый поток брал по несколько пикселей для обработки;

  ### Краткий алгоритм:
  Главный поток:
1. Инициализирует начальные данные (гененрирует случайные данные (массив rgba-векторов)) и начальное положение камеры;
2. Запускает поток рендера;
3. Каждый кадр реагирует на ввод (меняет положение камеры (поворот вокруг (0, 0,0 ) и зум));
4. Каждый кадр случайно меняет 1% данных (в реальных приложениях здесь могла быть комплексная логика);
5. Отправляет данные в поток рендера.

  Рендер поток:
    1. Инициализирует окно, обработчик ввода и необходимые для рендера ресурсы (1 шейдер, 1 меш (полноэкранный квадрат), 1 текстуру);
    2. Каждый кадр синхронизирует данные с главным потоком;
    3. Каждый кадр обрабатывает ввод;
    4. Каждый кадр генерирует текстуру для вывода:
      - Задано количество рабочих потоков.
      - Область окна делится на равные участки (несколько пикселей) между рабочими потоками.
      - Каждый поток за раз обрабатывает один пиксель: с противоположной от камеры стороны бросается луч в камеру; луч последовательно пересекает кубы (частицы из 3D массива) в порядке приближения к камере, производя альфа смешивание; результат записывается в текстуру.
    5. Каждый кадр загружает текстуру на gpu и выводит на экран (средствами OpenGL).

  Между главным и рендер потоком данные синхронизировались с использованием мьютексов, это место яаляется потенциальным бутылочным горлышком, поэтому была попытка максимально его синхронизировать. В фреймворке Qt для этих целей в середине кадра для синхронизации останавливаются оба потока. 

  Между потоками, осуществляющими рейтрейсинг, синхронизация не требуется, они только читают входные данные, не взаимодействуют между собой и пишут выходные значения в разные области памяти.
  
## Результаты
3D массив брался размером 32x32x32.
Размер окна 120x64 пикселя.
Время работы главного потока не замерял, т.к. нет необходимости. Время работы однопоточной версии не замерял, т.к. требует переписывания всего кода, в теории, время однопоточного кадра = время кадра главного потока + время кадра потока рендера - время на синхронизацию.
Общее время работы всего потока рендера так же не стал приводить, только время работы непосредственно рейтрейсинга:
Среднее время создания изображения в зависимости от числа потоков, выполняющих рейтрейсинг:
1: 0.195963
2: 0.106196
3: 0.0757884
4: 0.0672739
5: 0.0566405
6: 0.0501067
7: 0.0473996
8: 0.0509878
9: 0.0597578
10: 0.0618861

Дальше нет смыла проверять, т.к. на моем устройстве всего 8 ядер. Нелинейный прирост производительности можно связать с посторонними процессами на устройве (в дополнительных измерениях влияение открытого браузера четко прослеживается:) ). Так же было выяснено, что большую часть кадра съедает синхронизация и опрации с OpenGL .
## Заключение
Обработка изображений на cpu даже с использованием потоков является ресурсозатратной процедурой, для поставленной задачи лучше использовать CUDA, Vulkan или другие вычислительные API для работы с видеокартой. Как решить задачу используя классические походы (OpenGL), я не смог придумать, центральной проблемой является z-сортировка для корректной прозрачности.
Для себя узнал, что все OpenGL объекты должны создаваться в одном потоке (контекст, шейдеры, буфферы и т.д.).
